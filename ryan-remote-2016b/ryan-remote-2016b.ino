
// ================================================================
// ===               2.4Ghz Transceiver Includes                ===
// ================================================================
#include <SPI.h>  // Library for SPI communications used by the nRF24L01 radio
#include <Wire.h>
#include "libs/RadioHead/RH_NRF24.h"        // Max we can send is 28 bytes of data 
#include "libs/RadioHead/RH_NRF24.cpp"
#include "libs/RadioHead/RHGenericSPI.h"
#include "libs/RadioHead/RHGenericSPI.cpp"
#include "libs/RadioHead/RHHardwareSPI.h"
#include "libs/RadioHead/RHHardwareSPI.cpp"
#include "libs/RadioHead/RadioHead.h"
#include "libs/RadioHead/RHGenericDriver.h"
#include "libs/RadioHead/RHGenericDriver.cpp"
#include "libs/RadioHead/RHNRFSPIDriver.h"
#include "libs/RadioHead/RHNRFSPIDriver.cpp"

RH_NRF24 nrf24(14, 10);      //CE, CSN

// ================================================================
// ===                  OLED Display Includes                   ===
// ================================================================

#define I2C_ADDRESS 0x3D
#include "SSD1306Ascii.h"
#include "SSD1306AsciiAvrI2c.h"

SSD1306AsciiAvrI2c display;

/*#include "libs/Adafruit_GFX/Adafruit_GFX.h"
#include "libs/Adafruit_GFX/Adafruit_GFX.cpp"
#include "libs/Adafruit_SSD1306/Adafruit_SSD1306.h"
#include "libs/Adafruit_SSD1306/Adafruit_SSD1306.cpp"
#include "libs/Adafruit_GFX/Fonts/TomThumb.h"
#define OLED_RESET 3
Adafruit_SSD1306 display(OLED_RESET);*/

//display library causes the remote to freeze, with it enabled, it uses
//1725bytes of dynamic memory (84%), without it, it uses 493bytes (24%)

// ================================================================
// ===                     EEPROM Includes                      ===
// ================================================================
#include <EEPROM.h>          // EEPROM library to store non volatile channel varaible
// ================================================================
// ===                      Robot Pin Defines                   ===
// ================================================================

#define PIN_A 2      // Right D pad up button
#define PIN_B 8      // Right D pad right button
#define PIN_C 9      // Right D pad down button
#define PIN_D 15     // Right D pad left button

#define PIN_UP 4     // Left D pad up button
#define PIN_RIGHT 7  // Left D pad right button
#define PIN_DOWN 5   // Left D pad down button
#define PIN_LEFT 6   // Left D pad left button

#define PIN_TOP_RIGHT 1 // Top Right function switch is on the TX pin
#define PIN_TOP_LEFT 0 // Top Left function switch is on the RX pin

#define PIN_F 1 // Top Right function switch is on the TX pin
#define PIN_E 0 // Top Left function switch is on the RX pin

#define Y_LED 3  // Yellow low batt indicator LED 
#define R_LED 17 // Red TX indicator LED 

#define HEAD_R_LED 23   // Red LED on head PCB Pin PB7 = D23
#define HEAD_G_LED 22   // Green LED on head PCB Pin PB6 = D22
#define HEAD_B_LED 16  // Blue LED on head PCB Pin PC2 = A2 = D16

#define PIN_HEAD_A 20 // *ANALOG ONLY PIN ADC6/A6/D20 - Must be read with analog read* A button on head PCB
#define PIN_HEAD_B 21 // *ANALOG ONLY PIN ADC7/A7/D21 - Must be read with analog read* B button on head PCB


#define A 0  // Right D pad up button
#define B 1  // Right D pad right button
#define C 2  // Right D pad down button
#define D 3  // Right D pad left button

#define UP 4    // Left D pad up button
#define RIGHT 5 // Left D pad right button
#define DOWN 6  // Left D pad down button
#define LEFT 7  // Left D pad left button

#define E 0 // Top Right function switch is on the TX pin
#define F 1 // Top Left function switch is on the RX pin

#define HEAD_A 2 // *ANALOG ONLY PIN ADC6/A6/D20 - Must be read with analog read* A button on head PCB
#define HEAD_B 3 // *ANALOG ONLY PIN ADC7/A7/D21 - Must be read with analog read* B button on head PCB

// ================================================================
// ===                  Variable Definitions                    ===
// ================================================================

uint8_t sendBuffer[2]; //array of unsigned 8-bit type - 28 is the max message length for the nrf24L01 radio

unsigned char buttons = 0; // holds current value of all 8 buttons using bit values
unsigned char buttons2 = 0; // holds current value of all 8 buttons using bit values

unsigned char txChannel = 0; // Channel for the NRF24l01 transmitter 0-83 valid

uint8_t rcvBuffer[7];
uint8_t len = sizeof(rcvBuffer);
bool rcvState;

unsigned long loopTime;
unsigned long lastMillis;

long readVcc() {
  long result;
  // Read 1.1V reference against AVcc
  ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
  delay(2); // Wait for Vref to settle
  ADCSRA |= _BV(ADSC); // Convert
  while (bit_is_set(ADCSRA,ADSC));
  result = ADCL;
  result |= ADCH<<8;
  result = 1126400L / result; // Back-calculate AVcc in mV
  return result;
}

// use this utility to generate new bitmaps http://javl.github.io/image2cpp/
/*const unsigned char myBitmap [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7e, 0x1f, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7e, 0x1f, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7e, 0x1f, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7e, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7e, 0x1f, 0x1f, 0xf0, 0x7f, 0xc0, 0x3f, 0xe0, 0xf9, 0xf0, 0x7f, 0xc0, 0x7f, 0xc0, 0x00, 0x00, 
0x7e, 0x1f, 0x1f, 0xf0, 0x7f, 0xc0, 0x3f, 0xe0, 0xf9, 0xf0, 0x7f, 0xc0, 0x7f, 0xc0, 0x00, 0x00, 
0x7f, 0xff, 0x1f, 0xfc, 0x7f, 0xc0, 0x3f, 0xf8, 0xf9, 0xf1, 0xff, 0xf0, 0x7f, 0xe0, 0x00, 0x00, 
0x7f, 0xff, 0x00, 0xfc, 0x0f, 0xc0, 0x01, 0xf8, 0xf9, 0xf1, 0xfb, 0xf0, 0x03, 0xe0, 0x00, 0x00, 
0x7f, 0xff, 0x00, 0xfc, 0x0f, 0xc0, 0x01, 0xf8, 0xff, 0xf1, 0xfb, 0xf0, 0x03, 0xe0, 0x00, 0x00, 
0x7f, 0xff, 0x00, 0xfc, 0x0f, 0xc0, 0x01, 0xf8, 0xff, 0xe1, 0xfb, 0xf0, 0x03, 0xe0, 0x00, 0x00, 
0x7f, 0xff, 0x1f, 0xfc, 0x0f, 0xc0, 0x3f, 0xf8, 0xff, 0xe1, 0xff, 0xf0, 0x7f, 0xe0, 0x00, 0x00, 
0x7f, 0xff, 0x1f, 0xfc, 0x0f, 0xc0, 0x3f, 0xf8, 0xff, 0x81, 0xff, 0xf0, 0x7f, 0xe0, 0x00, 0x00, 
0x7f, 0xff, 0x7f, 0xfc, 0x0f, 0xc0, 0xff, 0xf8, 0xff, 0xe1, 0xff, 0xf1, 0xff, 0xe0, 0x00, 0x00, 
0x1f, 0xfc, 0x7c, 0xfc, 0x0f, 0xc0, 0xf9, 0xf8, 0xff, 0xe1, 0xf8, 0x01, 0xf3, 0xe0, 0x00, 0x00, 
0x1f, 0xfc, 0x7c, 0xfc, 0x0f, 0xc0, 0xf9, 0xf8, 0xff, 0xf1, 0xf8, 0x01, 0xf3, 0xe0, 0x00, 0x00, 
0x1f, 0xfc, 0x7c, 0xfc, 0x0f, 0xc0, 0xf9, 0xf8, 0xf9, 0xf1, 0xf8, 0x01, 0xf3, 0xe0, 0x00, 0x00, 
0x1f, 0xfc, 0x7f, 0xfc, 0x7f, 0xf8, 0xff, 0xf8, 0xf9, 0xf1, 0xff, 0xc1, 0xff, 0xe0, 0x00, 0x00, 
0x1f, 0xfc, 0x1f, 0xfc, 0x7f, 0xf8, 0x3f, 0xf8, 0xf9, 0xf0, 0x7f, 0xc0, 0x7f, 0xe0, 0x00, 0x00, 
0x1f, 0xfc, 0x1f, 0xfc, 0x7f, 0xf8, 0x3f, 0xf8, 0xf9, 0xf0, 0x7f, 0xc0, 0x7f, 0xe0, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7f, 0xf0, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7f, 0xf0, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7f, 0xfc, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7e, 0x7c, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7e, 0x7c, 0x1f, 0xf0, 0x7f, 0xe0, 0x3f, 0xe0, 0xff, 0xf1, 0xff, 0x00, 0x7f, 0xc0, 0xff, 0xe0, 
0x7e, 0x7c, 0x1f, 0xf0, 0x7f, 0xe0, 0x3f, 0xe0, 0xff, 0xf1, 0xff, 0x00, 0x7f, 0xc0, 0xff, 0xe0, 
0x7e, 0x7c, 0x7f, 0xfc, 0x7f, 0xf8, 0xff, 0xf8, 0xff, 0xf1, 0xff, 0x01, 0xff, 0xe3, 0xff, 0xe0, 
0x7e, 0x7c, 0x7c, 0xfc, 0x7c, 0xf8, 0xf9, 0xf8, 0x7e, 0x00, 0x1f, 0x01, 0xf3, 0xe3, 0xf0, 0x00, 
0x7f, 0xfc, 0x7c, 0xfc, 0x7c, 0xf8, 0xf9, 0xf8, 0x7e, 0x00, 0x1f, 0x01, 0xf3, 0xe3, 0xf0, 0x00, 
0x7f, 0xf0, 0x7c, 0xfc, 0x7c, 0xf8, 0xf9, 0xf8, 0x7e, 0x00, 0x1f, 0x01, 0xf0, 0x03, 0xf0, 0x00, 
0x7f, 0xf0, 0x7c, 0xfc, 0x7c, 0xf8, 0xf9, 0xf8, 0x7e, 0x00, 0x1f, 0x01, 0xf0, 0x03, 0xff, 0x80, 
0x7f, 0xf0, 0x7c, 0xfc, 0x7c, 0xf8, 0xf9, 0xf8, 0x7e, 0x00, 0x1f, 0x01, 0xf0, 0x00, 0xff, 0x80, 
0x7f, 0xfc, 0x7c, 0xfc, 0x7c, 0xf8, 0xf9, 0xf8, 0x7e, 0x00, 0x1f, 0x01, 0xf0, 0x00, 0xff, 0xe0, 
0x7e, 0x7c, 0x7c, 0xfc, 0x7c, 0xf8, 0xf9, 0xf8, 0x7e, 0x00, 0x1f, 0x01, 0xf0, 0x00, 0x03, 0xe0, 
0x7e, 0x7c, 0x7c, 0xfc, 0x7c, 0xf8, 0xf9, 0xf8, 0x7e, 0x00, 0x1f, 0x01, 0xf3, 0xe0, 0x03, 0xe0, 
0x7e, 0x7c, 0x7c, 0xfc, 0x7c, 0xf8, 0xf9, 0xf8, 0x7e, 0x00, 0x1f, 0x01, 0xf3, 0xe0, 0x03, 0xe0, 
0x7e, 0x7c, 0x7f, 0xfc, 0x7f, 0xf8, 0xff, 0xf8, 0x7f, 0xf1, 0xff, 0xf1, 0xff, 0xe3, 0xff, 0xe0, 
0x7e, 0x7c, 0x1f, 0xf0, 0x7f, 0xe0, 0x3f, 0xe0, 0x1f, 0xf1, 0xff, 0xf0, 0x7f, 0xc3, 0xff, 0x80, 
0x7e, 0x7c, 0x1f, 0xf0, 0x7f, 0xe0, 0x3f, 0xe0, 0x1f, 0xf1, 0xff, 0xf0, 0x7f, 0xc3, 0xff, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

};*/

void updateChannel(void)
{
  if (bitRead(buttons2, HEAD_A) == 1)   // If the button A on the head PCB is pushed 
  {
    txChannel--;                        // Decrement the txChannel
    if (txChannel > 83) txChannel = 83; // roll over from 0 to 83 to keep within valid range
    nrf24.setChannel(txChannel);       // Update the transmitter to use the new txChannel setting
    EEPROM.update(0, txChannel);       // Store the new value in EEPROM location 0 so it will be kept even after power off
  }
  else if (bitRead(buttons2, HEAD_B) == 1)// If the button B on the head PCB is pushed 
  {
    txChannel++;                       // Increment the txChannel
    if (txChannel > 83) txChannel = 0; // roll over from 83 to 0 to keep within valid range
    nrf24.setChannel(txChannel);       // Update the transmitter to use the new txChannel setting
    EEPROM.update(0, txChannel);       // Store the new value in EEPROM location 0 so it will be kept even after power off
  }

}
// ================================================================
// ===                      INITIAL SETUP                       ===
// ================================================================

void setup()
{

// ================================================================
// ===                     Robot Pin Setup                      ===
// ================================================================

  pinMode(R_LED, OUTPUT);
  pinMode(Y_LED, OUTPUT);
  pinMode(HEAD_R_LED, OUTPUT);
  pinMode(HEAD_G_LED, OUTPUT);
  pinMode(HEAD_B_LED, OUTPUT);

  digitalWrite(HEAD_R_LED, HIGH); // Turn off the Red LED - Active LOW
  digitalWrite(HEAD_G_LED, HIGH); // Turn off the Green LED
  digitalWrite(HEAD_B_LED, HIGH); // Turn off the Blue LED
  
  digitalWrite(R_LED, HIGH); // Turn on the Red LED - Active HIGH
  digitalWrite(Y_LED, HIGH); // Turn on the Red LED - Active HIGH
 // digitalWrite(HEAD_R_LED, LOW); // Turn on the Red LED - Active LOW
 // digitalWrite(HEAD_G_LED, LOW); // Turn on the Green LED
 // digitalWrite(HEAD_B_LED, LOW); // Turn on the Blue LED
  
  pinMode(PIN_A, INPUT_PULLUP); // Set pushbutton pins to inputs
  pinMode(PIN_B, INPUT_PULLUP);
  pinMode(PIN_C, INPUT_PULLUP);
  pinMode(PIN_D, INPUT_PULLUP);
  
  pinMode(PIN_UP, INPUT_PULLUP);
  pinMode(PIN_RIGHT, INPUT_PULLUP);
  pinMode(PIN_DOWN, INPUT_PULLUP);
  pinMode(PIN_LEFT, INPUT_PULLUP);

  pinMode(PIN_F, INPUT_PULLUP);
  pinMode(PIN_E, INPUT_PULLUP);

  pinMode(PIN_HEAD_A, INPUT_PULLUP);
  pinMode(PIN_HEAD_B, INPUT_PULLUP);
  
  
// ===================++===========================================
// ===             nrF34L01 Transceiver Setup                   ===
// ================================================================

  nrf24.init();
  // Defaults after init are 2.402 GHz (channel 2), 2Mbps, 0dBm
  txChannel = EEPROM.read(0);
  nrf24.setChannel(txChannel); // Set the desired Transceiver channel valid values are 0-127, in the US only channels 0-83 are within legal bands
  nrf24.setRF(RH_NRF24::DataRate2Mbps, RH_NRF24::TransmitPower0dBm);   
//  #define addressNRF 0xE7E7E7E7E4
//  nrf24.setNetworkAddress(addressNRF,sizeof(addressNRF));

// ===================++===========================================
// ===                     OLED Display Setup                   ===
// ================================================================
  Serial.begin(9600);

  display.begin(&Adafruit128x64, I2C_ADDRESS);  // initialize with the I2C addr 0x3D (for the 128x64)
  display.setFont(System5x7);
  display.println("Press top left button");

// Turn off all LEDs  
  digitalWrite(R_LED, LOW); // Turn off the Red LED
  digitalWrite(Y_LED, LOW); // Turn off the Yellow LED


  
} // End setup function

// ================================================================
// ===                    MAIN PROGRAM LOOP                     ===
// ================================================================

void loop(){
  updateChannel();
  
// ================================================================
// ===                       Read Buttons                       ===
// ================================================================

// We use the "bitWrite" function to change each bit individually in the "buttons" variable depending on the state of each button.  
// This allows us to store all 8 button values in one 8 bit variable which can then be easily sent to the robot for decoding. 
  bitWrite(buttons, A, !(digitalRead(PIN_A))); //So here the bit zero bit (right most bit) in "buttons" will be set to the current state of the button named "A"
  bitWrite(buttons, B, !(digitalRead(PIN_B)));
  bitWrite(buttons, C, !(digitalRead(PIN_C)));
  bitWrite(buttons, D, !(digitalRead(PIN_D)));
  bitWrite(buttons, UP, !(digitalRead(PIN_UP)));
  bitWrite(buttons, RIGHT, !(digitalRead(PIN_RIGHT))); 
  bitWrite(buttons, DOWN, !(digitalRead(PIN_DOWN)));
  bitWrite(buttons, LEFT, !(digitalRead(PIN_LEFT)));

  bitWrite(buttons2, F, !(digitalRead(PIN_F)));
  bitWrite(buttons2, E, !(digitalRead(PIN_E)));

  if (analogRead(PIN_HEAD_A) < 128) bitWrite(buttons2, HEAD_A, HIGH);
  else bitWrite(buttons2, HEAD_A, LOW);
  
  if (analogRead(PIN_HEAD_B) < 128) bitWrite(buttons2, HEAD_B, HIGH);
  else bitWrite(buttons2, HEAD_B, LOW);

  if ((buttons != 0)||(buttons2 != 0)) // If any buttons are being pushed
  {
    digitalWrite(R_LED, HIGH); // Turn on the Red LED
  }
  else
  {
    digitalWrite(R_LED, LOW); // Turn off the Red LED
  }
  
  //display.clearDisplay();
  //display.setCursor(0,7); 
  //display.print("Buttons:  ");
  //display.println(buttons);
  //display.print("Buttons2:  ");
  //display.println(buttons2);
  //display.print("Channel:  ");
  //display.println(txChannel);
  //display.display();
  
// ================================================================
// ===                    Send Data to Robot                    ===
// ================================================================

  sendBuffer[0] = buttons; // Set the sendBuffer to the button state
  //sendBuffer[1] = rcvBuffer[0]; // Set the sendBuffer to the button state
  sendBuffer[1] = loopTime; // Set the sendBuffer to the button state
  nrf24.send(sendBuffer, sizeof(sendBuffer)); // Send the buffer
  nrf24.waitPacketSent();   // Wait for the radio to finish transmitting
// ================================================================
// ===                  Read Data From Robot                    ===
// ================================================================  
  if (nrf24.waitAvailableTimeout(1)) // The wait time needs to be as low as possible so as to not impair the responsivness of the manual controls
  { 
      nrf24.recv(rcvBuffer, &len);
      rcvState = true;
  } 
  else
  {
    rcvState = false;
  }
// ================================================================
// ===                       Update Display                     ===
// ================================================================  
  loopTime = millis() - lastMillis;
  lastMillis = millis();


  if (!digitalRead(PIN_E))
  {
    display.clear();
    //display.setCursor(0,7); 
    display.print("Buttons:  ");
    display.println(buttons);
    display.print("Buttons2: ");
    display.println(buttons2);
    display.print("Channel:  ");
    display.println(txChannel);
    display.print("LoopTime: ");
    display.println(loopTime);
    display.print("RcvBuffer0: ");
    display.println(rcvBuffer[0]);
    display.print("RcvBuffer1: ");
    display.println(rcvBuffer[1]);
    display.print("RcvState:  ");
    display.println(rcvState);
  }
} // End main loop

